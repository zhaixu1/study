<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 
        Map 可以理解为映射。 拥有键值对的对象数组。
        1. 创建方法： const m = new Map(), 传入参数是键值对数组。如下
        2. 添加方法 m.set('name', 'zhangsan'). 获取 m.set('name'), m.has('name'). 删除 m.delete('name')  m.clear()
        3. map的键可以是任何类型，包括不限于 整数，函数，对象等。
        4. 与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，可以根据插入顺序执行迭代操作。
        5. m.keys(), map.values(). 并且在遍历的时候如果键是对象，可以改变键的值。
        6. Object 和Map的比较： 
            ① 内存占用：Map大约可以比Object对存储50%
            ② 插入性能： 差不多，但是数据量大的话Map性能会好。
            ③ 查找速度： Object要比Map会好点。
            ④ 删除速度：Map好多。Object删除属性 部分浏览器一直有问题。
     -->
    <script>
        const map = new Map()
        console.log(map);

        const map1 = new Map([
            ["name", '张三'],
            ['age', 12]
        ])
        console.log(map1);  // Map(2) {'name' => '张三', 'age' => 12}
        console.log(map1['name']); // undefined, 所以使用对象获取value值的方式不适用。
        console.log(map1.size); // 2

        console.log(map1.keys(), 'keys');
        console.log(map1.values(), 'values');
        for (const key of map1.keys()) {
            console.log(key, 'key');
            console.log(key);
            // key = 'nh'
            console.log(map1.get(key), 'map.key1');
            console.log(key);
        }
        console.log(map1);
        // 自定义迭代器。
        let arr = [1,3,5,3,2]
        arr[Symbol.iterator] = function() {
            console.log(1);
        }

        let obj = {
            name: 'kasdf',
            age: 'sdff',
            car: 'sdfsdf'
        }
        console.log(obj);
        console.log(obj);

        // const map2 = new Map(['name', 'age', 12])
        // console.log(map2);   报错，不能是这种格式
    </script>

</head>
<body>
    
</body>
</html>